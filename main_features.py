# -*- coding: utf-8 -*-
"""Main_features.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BfmIKz1-eVsq1sUjXlojoy3XkF35OqIA
"""

import scipy.io
import numpy as np
import math
from scipy import signal

def nextpow2(i):
    p=1
    while True:
        if 2**p >= i:
            break
        else:
            p=p+1
    return p

def ALFF_fALFF(slow, ASamplePeriod, nDimTimePoints, AllVolume, plots=False):
    row,col=np.shape(AllVolume)
    #slow2, slow3, slow4 and slow5
    SlowHigh=[0.25, 0.198, 0.073, 0.027]
    SlowLow=[0.198, 0.073, 0.027, 0.01]

    HighCutoff=SlowHigh[slow] #the High edge of the pass band
    LowCutoff=SlowLow[slow]   #the low edge of the pass band
    
    sampleFreq 	 = 1/ASamplePeriod
    sampleLength = nDimTimePoints
    paddedLength = 2**(nextpow2(sampleLength))
    
    if (LowCutoff >= sampleFreq/2): # All high included
        idx_LowCutoff = paddedLength/2 + 1;
    else: # high cut off, such as freq > 0.01 Hz
        idx_LowCutoff = math.ceil(LowCutoff * paddedLength * ASamplePeriod + 1)
    # Change from round to ceil: idx_LowCutoff = round(LowCutoff *paddedLength *ASamplePeriod + 1);

    if (HighCutoff>=sampleFreq/2)and(HighCutoff==0):# All low pass
        idx_HighCutoff = paddedLength/2 + 1;
    else: #Low pass, such as freq < 0.08 Hz
        idx_HighCutoff =  np.fix (HighCutoff *paddedLength *ASamplePeriod + 1)
    # Change from round to fix: idx_HighCutoff	=round(HighCutoff *paddedLength *ASamplePeriod + 1);
    #Zero Padding
    a = np.zeros((paddedLength - sampleLength,len(AllVolume[2])))
    AllVolume = np.concatenate((AllVolume, a), axis=0)
    
    AllVolume=np.transpose(AllVolume)
    AllVolume = 2*np.true_divide(abs(scipy.fft(AllVolume)),sampleLength)
    AllVolume=np.transpose(AllVolume)
    
    print('Calculating Amplitude of Low Frequency Fluctuations (ALFF) for slow', slow+2,' ...')    
    ALFF_2D = np.mean(AllVolume[idx_LowCutoff:int(idx_HighCutoff)], axis=0)
    
    print('Calculating Fractional Amplitude of Low Frequency Fluctuations (fALFF) for slow', slow+2,' ...')
    num = np.sum(AllVolume[(idx_LowCutoff):int(idx_HighCutoff)],axis=0,dtype=float)
    den = np.sum(AllVolume[2:int(paddedLength/2 + 1)],axis=0,dtype=float)
    fALFF_2D =  num/den
       
    metricas = np.concatenate((ALFF_2D, fALFF_2D), axis=0).reshape((2,col))
    
    if plots:
        plt.figure()
        plt.title('Power Spectral Density')
        freq=np.arange(0.0, 1/ASamplePeriod, 1/(ASamplePeriod*np.shape(AllVolume)[0]))
        plt.plot(freq,AllVolume)
        
        plt.figure()
        plt.title('ALFF')
        plt.plot(metricas[0,:])
        
        plt.figure()
        plt.title('fALFF')
        plt.plot(metricas[1,:]) 
    
    return metricas

def Function_Jump(y, fs):
  print('Calculating Jump function 1...')
  Jump1=np.max(np.abs(np.diff(y, axis=0)*fs), axis=0)/np.std(y, axis=0)
  return Jump1

def VCF(y, fs):
    print('Calculating Variance of central frequency...')
    fy, px = signal.periodogram(y, fs, axis=0)
    sm0=np.dot(fy**0,px)/np.sum(px, axis=0)
    sm1=np.dot(fy**1,px)/np.sum(px, axis=0)
    sm2=np.dot(fy**2,px)/np.sum(px, axis=0)
    vc=(sm2/sm0) -((sm1/sm0)**2)
    return vc

def Metrics5(Data, TR, points):
  alff4=ALFF_fALFF(2,TR, points, Data, False)
  alff5=ALFF_fALFF(3,TR, points, Data, False)
  jump=Function_Jump(Data, 1/TR)    
  vcf=VCF(Data, 1/TR)
  print('\nOrder metrics\n fALFF slow 4,\n ALFF slow 4,\n vcf,\n ALFF slow 5 and\n jump')
  metrics=np.array([alff4[1,:], alff4[0,:], vcf, alff5[0,:], jump])
  return metrics

def Metrics6(Data, TR, points):
  alff4=ALFF_fALFF(2,TR, points, Data, False)
  alff5=ALFF_fALFF(3,TR, points, Data, False)
  jump=Function_Jump(Data, 1/TR)    
  vcf=VCF(Data, 1/TR)
  print('\nOrder metrics\n fALFF slow 4,\n ALFF slow 4,\n vcf,\n ALFF slow 5,\n jump and\n fALFF slow 5 ')
  metrics=np.array([alff4[1,:], alff4[0,:], vcf, alff5[0,:], jump, alff5[1,:]])
  return metrics

def downloadData():
  import os
  if os.path.exists('Data'):   
      print ('The folder already exists')
  else:
      print ('Downloading data...')
      os.system('mkdir Data')
      os.system('wget -nc https://www.dropbox.com/s/5668qyb69793m8p/Hand.zip?dl=1')
      os.system('unzip Hand.zip?dl=1 -d Data/')
      os.system('rm -r Hand.zip?dl=1')

if __name__=="__main__":

  downloadData()

  Dat = scipy.io.loadmat('Data/HandData.mat')
  Data=Dat['series']
  points=np.shape(Data)[0]
  TR=2.4
  
  print ('Time points and components ', np.shape(Data), '\n')  
  metrics=Metrics6(Data, TR, points)
  print(np.shape(metrics))